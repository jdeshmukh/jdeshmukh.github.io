@Inbook{Deshmukh2019,
    author      = {Deshmukh, Jyotirmoy V.  and Sankaranarayanan, Sriram},
    editor      = {Al Faruque, Mohammad Abdullah and Canedo, Arquimedes},
    title       = {Formal Techniques for Verification and Testing of Cyber-Physical Systems},
    bookTitle   = {Design Automation of Cyber-Physical Systems},
    year        = {2019},
    publisher   = {Springer International Publishing},
    address     = {Cham},
    pages       = {69--105},
    abstract    = {Modern cyber-physical systems (CPS) are often developed in a model-based development (MBD) paradigm. The MBD paradigm involves the construction of different kinds of models: (1) a plant model that encapsulates the physical components of the system (e.g., mechanical, electrical, chemical components) using representations based on differential and algebraic equations, (2) a controller model that encapsulates the embedded software components of the system, and (3) an environment model that encapsulates physical assumptions on the external environment of the CPS application. In order to reason about the correctness of CPS applications, we typically pose the following question: For all possible environment scenarios, does the closed-loop system consisting of the plant and the controller exhibit the desired behavior? Typically, the desired behavior is expressed in terms of properties that specify unsafe behaviors of the closed-loop system. Often, such behaviors are expressed using variants of real-time temporal logics. In this chapter, we will examine formal methods based on bounded-time reachability analysis, simulation-guided reachability analysis, deductive techniques based on safety invariants, and formal, requirement-driven testing techniques. We will review key results in the literature, and discuss the scalability and applicability of such systems to various academic and industrial contexts. We conclude this chapter by discussing the challenge to formal verification and testing techniques posed by newer CPS applications that use AI-based software components.}
}
